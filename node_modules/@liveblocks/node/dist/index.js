"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/authorize.ts
var _nodefetch = require('node-fetch'); var _nodefetch2 = _interopRequireDefault(_nodefetch);

// src/utils.ts
function isNonEmpty(value) {
  return typeof value === "string" && value.length > 0;
}
function assertNonEmpty(value, field) {
  if (!isNonEmpty(value)) {
    throw new Error(
      `Invalid value for field "${field}". Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`
    );
  }
}
function assertSecretKey(value, field) {
  if (!isNonEmpty(value) || !value.startsWith("sk_")) {
    throw new Error(
      `Invalid value for field "${field}". Secret keys must start with "sk_". Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`
    );
  }
}
function normalizeStatusCode(statusCode) {
  if (statusCode >= 200 && statusCode < 300) {
    return 200;
  } else if (statusCode >= 500) {
    return 503;
  } else {
    return 403;
  }
}
function urljoin(baseUrl, path) {
  const url = new URL(baseUrl);
  url.pathname = path;
  return url.toString();
}

// src/authorize.ts
async function authorize(options) {
  try {
    const { room, secret, userId, userInfo, groupIds } = (
      // Ensure we'll validate inputs at runtime
      options
    );
    assertNonEmpty(secret, "secret");
    assertNonEmpty(room, "room");
    assertNonEmpty(userId, "userId");
    const resp = await _nodefetch2.default.call(void 0, buildLiveblocksAuthorizeEndpoint(options, room), {
      method: "POST",
      headers: {
        Authorization: `Bearer ${secret}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        userId,
        userInfo,
        groupIds
      })
    });
    return {
      status: normalizeStatusCode(resp.status),
      body: await resp.text()
    };
  } catch (er) {
    return {
      status: 503,
      body: 'Call to "https://api.liveblocks.io/v2/rooms/:roomId/authorize" failed. See "error" for more information.',
      error: er
    };
  }
}
function buildLiveblocksAuthorizeEndpoint(options, roomId) {
  if (options.liveblocksAuthorizeEndpoint) {
    return options.liveblocksAuthorizeEndpoint.replace("{roomId}", roomId);
  }
  return `https://api.liveblocks.io/v2/rooms/${encodeURIComponent(
    roomId
  )}/authorize`;
}

// src/new-auth.ts


// src/Session.ts
var ALL_PERMISSIONS = Object.freeze([
  "room:write",
  "room:read",
  "room:presence:write",
  "comments:write",
  "comments:read"
]);
function isPermission(value) {
  return ALL_PERMISSIONS.includes(value);
}
var MAX_PERMS_PER_SET = 10;
var READ_ACCESS = Object.freeze([
  "room:read",
  "room:presence:write",
  "comments:read"
]);
var FULL_ACCESS = Object.freeze(["room:write", "comments:write"]);
var roomPatternRegex = /^[^*]{1,128}[*]?$/;
var Session = class {
  /** @internal */
  constructor(postFn, userId, userInfo) {
    this.FULL_ACCESS = FULL_ACCESS;
    this.READ_ACCESS = READ_ACCESS;
    /** @internal */
    this._sealed = false;
    /** @internal */
    this._permissions = /* @__PURE__ */ new Map();
    assertNonEmpty(userId, "userId");
    this._postFn = postFn;
    this._userId = userId;
    this._userInfo = userInfo;
  }
  /** @internal */
  getOrCreate(roomId) {
    if (this._sealed) {
      throw new Error("You can no longer change these permissions.");
    }
    let perms = this._permissions.get(roomId);
    if (perms) {
      return perms;
    } else {
      if (this._permissions.size >= MAX_PERMS_PER_SET) {
        throw new Error(
          "You cannot add permissions for more than 10 rooms in a single token"
        );
      }
      perms = /* @__PURE__ */ new Set();
      this._permissions.set(roomId, perms);
      return perms;
    }
  }
  allow(roomIdOrPattern, newPerms) {
    if (!roomPatternRegex.test(roomIdOrPattern)) {
      throw new Error("Invalid room name or pattern");
    }
    if (newPerms.length === 0) {
      throw new Error("Permission list cannot be empty");
    }
    const existingPerms = this.getOrCreate(roomIdOrPattern);
    for (const perm of newPerms) {
      if (!isPermission(perm)) {
        throw new Error(`Not a valid permission: ${perm}`);
      }
      existingPerms.add(perm);
    }
    return this;
  }
  /** @internal - For unit tests only */
  hasPermissions() {
    return this._permissions.size > 0;
  }
  /** @internal - For unit tests only */
  seal() {
    if (this._sealed) {
      throw new Error(
        "You cannot reuse Session instances. Please create a new session every time."
      );
    }
    this._sealed = true;
  }
  /** @internal - For unit tests only */
  serializePermissions() {
    return Object.fromEntries(
      Array.from(this._permissions.entries()).map(([pat, perms]) => [
        pat,
        Array.from(perms)
      ])
    );
  }
  /**
   * Call this to authorize the session to access Liveblocks. Note that this
   * will return a Liveblocks "access token". Anyone that obtains such access
   * token will have access to the allowed resources.
   */
  async authorize() {
    this.seal();
    if (!this.hasPermissions()) {
      return {
        status: 403,
        body: "Forbidden"
      };
    }
    try {
      const resp = await this._postFn("/v2/authorize-user", {
        // Required
        userId: this._userId,
        permissions: this.serializePermissions(),
        // Optional metadata
        userInfo: this._userInfo
      });
      return {
        status: normalizeStatusCode(resp.status),
        body: await resp.text()
      };
    } catch (er) {
      return {
        status: 503,
        body: 'Call to /v2/authorize-user failed. See "error" for more information.',
        error: er
      };
    }
  }
};

// src/new-auth.ts
var DEFAULT_BASE_URL = "https://api.liveblocks.io";
var Liveblocks = class {
  /**
   * Interact with the Liveblocks API from your Node.js backend.
   */
  constructor(options) {
    const options_ = options;
    const secret = options_.secret;
    assertSecretKey(secret, "secret");
    this._secret = secret;
    this._baseUrl = new URL(
      typeof options_.liveblocksBaseUrl === "string" ? options_.liveblocksBaseUrl : DEFAULT_BASE_URL
    );
  }
  /** @internal */
  async post(path, json) {
    const url = urljoin(this._baseUrl, path);
    const headers = {
      Authorization: `Bearer ${this._secret}`,
      "Content-Type": "application/json"
    };
    return _nodefetch2.default.call(void 0, url, { method: "POST", headers, body: JSON.stringify(json) });
  }
  /**
   * Prepares a new session to authorize a user to access Liveblocks.
   *
   * IMPORTANT:
   * Always make sure that you trust the user making the request to your
   * backend before calling .prepareSession()!
   *
   * @param userId Tell Liveblocks the user ID of the user to authorize. Must
   * uniquely identify the user account in your system. The uniqueness of this
   * value will determine how many MAUs will be counted/billed.
   *
   * @param options.userInfo Custom metadata to attach to this user. Data you
   * add here will be visible to all other clients in the room, through the
   * `other.info` property.
   *
   */
  prepareSession(userId, options) {
    return new Session(this.post.bind(this), userId, _optionalChain([options, 'optionalAccess', _ => _.userInfo]));
  }
  /**
   * Call this to authenticate the user as an actor you want to allow to use
   * Liveblocks.
   *
   * You should use this method only if you want to manage your permissions
   * through the Liveblocks Permissions API. This method is more complicated to
   * set up, but allows for finer-grained specification of permissions.
   *
   * Calling `.identifyUser()` only lets you securely identify a user (and what
   * groups they belong to). What permissions this user will end up having is
   * determined by whatever permissions you assign the user/group in your
   * Liveblocks account, through the Permissions API:
   * https://liveblocks.io/docs/rooms/permissions
   *
   * IMPORTANT:
   * Always verify that you trust the user making the request before calling
   * .identifyUser()!
   *
   * @param identity Tell Liveblocks the user ID of the user to authenticate.
   * Must uniquely identify the user account in your system. The uniqueness of
   * this value will determine how many MAUs will be counted/billed.
   *
   * If you also want to assign which groups this user belongs to, use the
   * object form and specify the `groupIds` property. Those `groupIds` should
   * match the groupIds you assigned permissions to via the Liveblocks
   * Permissions API, see
   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example
   *
   * @param options.userInfo Custom metadata to attach to this user. Data you
   * add here will be visible to all other clients in the room, through the
   * `other.info` property.
   */
  // These fields define the security identity of the user. Whatever you pass in here will define which
  async identifyUser(identity, options) {
    const path = "/v2/identify-user";
    const userId = typeof identity === "string" ? identity : identity.userId;
    const groupIds = typeof identity === "string" ? void 0 : identity.groupIds;
    assertNonEmpty(userId, "userId");
    try {
      const resp = await this.post(path, {
        userId,
        groupIds,
        // Optional metadata
        userInfo: _optionalChain([options, 'optionalAccess', _2 => _2.userInfo])
      });
      return {
        status: normalizeStatusCode(resp.status),
        body: await resp.text()
      };
    } catch (er) {
      return {
        status: 503,
        body: `Call to ${urljoin(
          this._baseUrl,
          path
        )} failed. See "error" for more information.`,
        error: er
      };
    }
  }
};

// src/webhooks.ts
var _crypto = require('crypto'); var _crypto2 = _interopRequireDefault(_crypto);
var _WebhookHandler = class _WebhookHandler {
  constructor(secret) {
    if (!secret)
      throw new Error("Secret is required");
    if (typeof secret !== "string")
      throw new Error("Secret must be a string");
    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)
      throw new Error("Invalid secret, must start with whsec_");
    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);
    this.secretBuffer = Buffer.from(secretKey, "base64");
  }
  /**
   * Verifies a webhook request and returns the event
   */
  verifyRequest(request) {
    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(
      request.headers
    );
    this.verifyTimestamp(timestamp);
    const signature = this.sign(`${webhookId}.${timestamp}.${request.rawBody}`);
    const expectedSignatures = rawSignatures.split(" ").map((rawSignature) => {
      const [, parsedSignature] = rawSignature.split(",");
      return parsedSignature;
    }).filter(isNotUndefined);
    if (expectedSignatures.includes(signature) === false)
      throw new Error(
        `Invalid signature, expected one of ${expectedSignatures.join(
          ", "
        )}, got ${signature}`
      );
    const event = JSON.parse(request.rawBody);
    this.verifyWebhookEventType(event);
    return event;
  }
  /**
   * Verifies the headers and returns the webhookId, timestamp and rawSignatures
   */
  verifyHeaders(headers) {
    const usingNativeHeaders = typeof Headers !== "undefined" && headers instanceof Headers;
    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;
    const sanitizedHeaders = {};
    Object.keys(normalizedHeaders).forEach((key) => {
      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];
    });
    const webhookId = sanitizedHeaders["webhook-id"];
    if (typeof webhookId !== "string")
      throw new Error("Invalid webhook-id header");
    const timestamp = sanitizedHeaders["webhook-timestamp"];
    if (typeof timestamp !== "string")
      throw new Error("Invalid webhook-timestamp header");
    const rawSignatures = sanitizedHeaders["webhook-signature"];
    if (typeof rawSignatures !== "string")
      throw new Error("Invalid webhook-signature header");
    return { webhookId, timestamp, rawSignatures };
  }
  /**
   * Signs the content with the secret
   * @param content
   * @returns `string`
   */
  sign(content) {
    return _crypto2.default.createHmac("sha256", this.secretBuffer).update(content).digest("base64");
  }
  /**
   * Verifies that the timestamp is not too old or in the future
   */
  verifyTimestamp(timestampHeader) {
    const now = Math.floor(Date.now() / 1e3);
    const timestamp = parseInt(timestampHeader, 10);
    if (isNaN(timestamp)) {
      throw new Error("Invalid timestamp");
    }
    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp too old");
    }
    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp in the future");
    }
  }
  /**
   * Ensures that the event is a known event type
   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node
   */
  verifyWebhookEventType(event) {
    if (event && event.type && [
      "storageUpdated",
      "userEntered",
      "userLeft",
      "roomCreated",
      "roomDeleted",
      "ydocUpdated"
    ].includes(event.type))
      return;
    throw new Error(
      "Unknown event type, please upgrade to a higher version of @liveblocks/node"
    );
  }
};
_WebhookHandler.secretPrefix = "whsec_";
var WebhookHandler = _WebhookHandler;
var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
var isNotUndefined = (value) => value !== void 0;




exports.Liveblocks = Liveblocks; exports.WebhookHandler = WebhookHandler; exports.authorize = authorize;
//# sourceMappingURL=index.js.map